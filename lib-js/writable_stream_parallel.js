// Generated by CoffeeScript 1.6.1
(function() {
  var NodeWritable, Writable, WritableState, WriteReq,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  NodeWritable = require('stream').Writable;

  WriteReq = (function() {

    function WriteReq(stream, len, chunk, encoding, cb) {
      var _this = this;
      this.stream = stream;
      this.len = len;
      this.chunk = chunk;
      this.encoding = encoding;
      this.cb = cb;
      this.doWrite = function() {
        return WriteReq.prototype.doWrite.apply(_this, arguments);
      };
      this.onWriteError = function() {
        return WriteReq.prototype.onWriteError.apply(_this, arguments);
      };
    }

    WriteReq.prototype.onWriteError = function() {
      var _this = this;
      if (this.sync) {
        return process.nextTick(function() {
          return _this.cb(er);
        });
      } else {
        return this.cb(er);
      }
    };

    WriteReq.prototype.doWrite = function() {
      var _this = this;
      this.stream.state.writing += 1;
      this.sync = true;
      return this.stream._write(this.chunk, this.encoding, function(er) {
        var afterWrite, finished;
        _this.stream.state.writing -= 1;
        _this.stream.state.length -= _this.len;
        if (er) {
          return _this.onWriteError();
        } else {
          finished = _this.stream.finishMaybe();
          if (!finished && !_this.stream.state.bufferProcessing && _this.stream.state.buffer.length) {
            _this.stream.clearBuffer();
          }
          afterWrite = function() {
            if (!finished) {
              _this.stream.onwriteDrain();
            }
            return _this.cb();
          };
          if (_this.sync) {
            return process.nextTick(function() {
              return afterWrite();
            });
          } else {
            return afterWrite();
          }
        }
      });
    };

    return WriteReq;

  })();

  WritableState = (function() {

    function WritableState(options) {
      var noDecode;
      this.maxWrites = options.maxWrites || 1;
      this.highWaterMark = ~~(options.highWaterMark || (16 * 1024));
      this.objectMode = !!options.objectMode;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.length = 0;
      this.writing = 0;
      this.buffer = [];
      this.bufferProcessing = false;
    }

    return WritableState;

  })();

  Writable = (function(_super) {

    __extends(Writable, _super);

    function Writable(options) {
      var _this = this;
      this.endWritable = function(cb) {
        return Writable.prototype.endWritable.apply(_this, arguments);
      };
      this.finishMaybe = function() {
        return Writable.prototype.finishMaybe.apply(_this, arguments);
      };
      this.end = function(chunk, encoding, cb) {
        return Writable.prototype.end.apply(_this, arguments);
      };
      this.onwriteDrain = function() {
        return Writable.prototype.onwriteDrain.apply(_this, arguments);
      };
      this.write = function(chunk, encoding, cb) {
        return Writable.prototype.write.apply(_this, arguments);
      };
      this.clearBuffer = function() {
        return Writable.prototype.clearBuffer.apply(_this, arguments);
      };
      this.writeOrBuffer = function(chunk, encoding, cb) {
        return Writable.prototype.writeOrBuffer.apply(_this, arguments);
      };
      this.decodeChunk = function(chunk, encoding) {
        return Writable.prototype.decodeChunk.apply(_this, arguments);
      };
      this.validChunk = function(chunk, cb) {
        return Writable.prototype.validChunk.apply(_this, arguments);
      };
      this.writeAfterEnd = function(cb) {
        return Writable.prototype.writeAfterEnd.apply(_this, arguments);
      };
      Writable.__super__.constructor.apply(this, arguments);
      this.state = new WritableState(options, this);
    }

    Writable.prototype.writeAfterEnd = function(cb) {
      var er;
      er = new Error('write after end');
      this.emit('error', er);
      return process.nextTick(function() {
        return cb(er);
      });
    };

    Writable.prototype.validChunk = function(chunk, cb) {
      var er, valid;
      valid = true;
      if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && (chunk != null) && !this.state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
        this.emit('error', er);
        process.nextTick(function() {
          return cb(er);
        });
        valid = false;
      }
      return valid;
    };

    Writable.prototype.decodeChunk = function(chunk, encoding) {
      if (!this.state.objectMode && this.state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    };

    Writable.prototype.writeOrBuffer = function(chunk, encoding, cb) {
      var len, ret, writeReq;
      chunk = this.decodeChunk(chunk, encoding);
      len = this.state.objectMode ? 1 : chunk.length;
      this.state.length += len;
      ret = this.state.length < this.state.highWaterMark;
      this.state.needDrain = !ret;
      writeReq = new WriteReq(this, len, chunk, encoding, cb);
      if (this.state.writing >= this.state.maxWrites) {
        this.state.buffer.push(writeReq);
      } else {
        writeReq.doWrite();
      }
      return ret;
    };

    Writable.prototype.clearBuffer = function() {
      var c, writing_before;
      this.state.bufferProcessing = true;
      c = 0;
      while (c < this.state.buffer.length) {
        writing_before = this.state.writing;
        this.state.buffer[c].doWrite();
        if (writing_before + 1 === this.state.writing && this.state.writing >= this.state.maxWrites) {
          c++;
          break;
        }
        c++;
      }
      this.state.bufferProcessing = false;
      if (c < this.state.buffer.length) {
        return this.state.buffer = this.state.buffer.slice(c);
      } else {
        return this.state.buffer.length = 0;
      }
    };

    Writable.prototype.write = function(chunk, encoding, cb) {
      var ret;
      ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (typeof cb !== 'function') {
        cb = (function() {});
      }
      if (this.state.ended) {
        this.writeAfterEnd(cb);
      } else if (this.validChunk(chunk, cb)) {
        ret = this.writeOrBuffer(chunk, encoding, cb);
      }
      return ret;
    };

    Writable.prototype.onwriteDrain = function() {
      if (this.state.length === 0 && this.state.needDrain) {
        this.state.needDrain = false;
        return this.emit('drain');
      }
    };

    Writable.prototype.end = function(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk != null) {
        this.write(chunk, encoding);
      }
      if (!this.state.ending && !this.state.finished) {
        return this.endWritable(cb);
      }
    };

    Writable.prototype.finishMaybe = function() {
      if (this.state.ending && this.state.length === 0 && !this.state.finished) {
        this.state.finished = true;
        this.emit('finish');
      }
      return this.state.finished;
    };

    Writable.prototype.endWritable = function(cb) {
      this.state.ending = true;
      this.finishMaybe();
      if (cb) {
        if (this.state.finished) {
          process.nextTick(cb);
        } else {
          this.once('finish', cb);
        }
      }
      return this.state.ended = true;
    };

    return Writable;

  })(NodeWritable);

  module.exports = {
    Writable: Writable
  };

}).call(this);
