// Generated by CoffeeScript 1.6.1
(function() {
  var NodeWritable, Writable, WriteReq,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  NodeWritable = require("" + __dirname + "/../node_modules/readable-stream/writable");

  WriteReq = (function() {

    function WriteReq(stream, len, chunk, encoding, cb) {
      var _this = this;
      this.stream = stream;
      this.len = len;
      this.chunk = chunk;
      this.encoding = encoding;
      this.cb = cb;
      this.doWrite = function() {
        return WriteReq.prototype.doWrite.apply(_this, arguments);
      };
      this.onWriteError = function(er) {
        return WriteReq.prototype.onWriteError.apply(_this, arguments);
      };
    }

    WriteReq.prototype.onWriteError = function(er) {
      var _this = this;
      if (this.sync) {
        return process.nextTick(function() {
          return _this.cb(er);
        });
      } else {
        return this.cb(er);
      }
    };

    WriteReq.prototype.doWrite = function() {
      var state,
        _this = this;
      state = this.stream._writableState;
      state.writing += 1;
      this.sync = true;
      return this.stream._write(this.chunk, this.encoding, function(er) {
        var afterWrite, finished;
        state.writing -= 1;
        state.length -= _this.len;
        if (er) {
          return _this.onWriteError(er);
        } else {
          finished = _this.stream.finishMaybe();
          if (!finished && !state.bufferProcessing && state.buffer.length) {
            _this.stream.clearBuffer();
          }
          afterWrite = function() {
            if (!finished) {
              _this.stream.onwriteDrain();
            }
            return _this.cb();
          };
          if (_this.sync) {
            return process.nextTick(function() {
              return afterWrite();
            });
          } else {
            return afterWrite();
          }
        }
      });
    };

    return WriteReq;

  })();

  Writable = (function(_super) {

    __extends(Writable, _super);

    function Writable(options) {
      var _this = this;
      this.finishMaybe = function() {
        return Writable.prototype.finishMaybe.apply(_this, arguments);
      };
      this.onwriteDrain = function() {
        return Writable.prototype.onwriteDrain.apply(_this, arguments);
      };
      this.clearBuffer = function() {
        return Writable.prototype.clearBuffer.apply(_this, arguments);
      };
      this.writeOrBuffer = function(chunk, encoding, cb) {
        return Writable.prototype.writeOrBuffer.apply(_this, arguments);
      };
      this.decodeChunk = function(chunk, encoding) {
        return Writable.prototype.decodeChunk.apply(_this, arguments);
      };
      this.validChunk = function(chunk, cb) {
        return Writable.prototype.validChunk.apply(_this, arguments);
      };
      this.writeAfterEnd = function(cb) {
        return Writable.prototype.writeAfterEnd.apply(_this, arguments);
      };
      this.write = function(chunk, encoding, cb) {
        return Writable.prototype.write.apply(_this, arguments);
      };
      Writable.__super__.constructor.call(this, options);
      this._writableState.maxWrites = (options != null ? options.maxWrites : void 0) || 1;
      this._writableState.writing = 0;
    }

    Writable.prototype.write = function(chunk, encoding, cb) {
      var ret, state;
      state = this._writableState;
      ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (typeof cb !== 'function') {
        cb = (function() {});
      }
      if (state.ended) {
        this.writeAfterEnd(cb);
      } else if (this.validChunk(chunk, cb)) {
        ret = this.writeOrBuffer(chunk, encoding, cb);
      }
      return ret;
    };

    Writable.prototype.writeAfterEnd = function(cb) {
      var er;
      er = new Error('write after end');
      this.emit('error', er);
      return process.nextTick(function() {
        return cb(er);
      });
    };

    Writable.prototype.validChunk = function(chunk, cb) {
      var er, state, valid;
      state = this._writableState;
      valid = true;
      if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && (chunk != null) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
        this.emit('error', er);
        process.nextTick(function() {
          return cb(er);
        });
        valid = false;
      }
      return valid;
    };

    Writable.prototype.decodeChunk = function(chunk, encoding) {
      var state;
      state = this._writableState;
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    };

    Writable.prototype.writeOrBuffer = function(chunk, encoding, cb) {
      var len, ret, state, writeReq;
      state = this._writableState;
      chunk = this.decodeChunk(chunk, encoding);
      len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      ret = state.length < state.highWaterMark;
      state.needDrain = !ret;
      writeReq = new WriteReq(this, len, chunk, encoding, cb);
      if (state.writing >= state.maxWrites) {
        state.buffer.push(writeReq);
      } else {
        writeReq.doWrite();
      }
      return ret;
    };

    Writable.prototype.clearBuffer = function() {
      var c, state, writing_before;
      state = this._writableState;
      state.bufferProcessing = true;
      c = 0;
      while (c < state.buffer.length) {
        writing_before = state.writing;
        state.buffer[c].doWrite();
        if (writing_before + 1 === state.writing && state.writing >= state.maxWrites) {
          c++;
          break;
        }
        c++;
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length) {
        return state.buffer = state.buffer.slice(c);
      } else {
        return state.buffer.length = 0;
      }
    };

    Writable.prototype.onwriteDrain = function() {
      var state;
      state = this._writableState;
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        return this.emit('drain');
      }
    };

    Writable.prototype.finishMaybe = function() {
      var state;
      state = this._writableState;
      if (state.ending && state.length === 0 && !state.finished) {
        state.finished = true;
        this.emit('finish');
      }
      return state.finished;
    };

    return Writable;

  })(NodeWritable);

  module.exports = Writable;

}).call(this);
